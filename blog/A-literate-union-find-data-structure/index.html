<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>A literate union-find data structure</title>
    <meta name="viewport" content="width=device-width,
                                   initial-scale=1.0">
    <link href="/dist/css/bootstrap.min.css" rel="stylesheet" media="screen">
    <link href="/css/my.css" rel="stylesheet" media="screen">
    <link rel="alternate" type="application/rss+xml" title="L language - blog" href="/blog/rss.xml" />
    <link rel="alternate" type="application/atom+xml" title="L language - blog" href="/blog/atom.xml" />

    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-42249123-1', 'l-lang.org');
      ga('send', 'pageview');
    </script>

  </head>

  <body>
     




   <div class="navbar navbar-inverse navbar-fixed-top navbar-default">
     <div class="container">
       <div class="navbar-header">
         <button
            type="button" class="navbar-toggle" data-toggle="collapse"
            data-target="#my-navbar">
           <span class="sr-only">Toggle navigation</span>
           
           <span class="icon-bar"></span>
           <span class="icon-bar"></span>
           <span class="icon-bar"></span>
         </button>
         <a class="navbar-brand" href="/"><i>The</i> L <i>language</i></a>
       </div>
       <div id="my-navbar" class="navbar-collapse collapse">
             <ul class="nav navbar-nav">
               

               
               
               

               
               <li class="dropdown">
                 <a href="/documentation/compiler_hyperbook" class="dropdown-toggle"
                    data-toggle="dropdown"> Documentation <b class="caret"></b> </a>
                 <ul class="dropdown-menu list-group">
                   <li class="dropdown-header">Introduction to L</li>
                   <li><a href="/documentation/intro/short">A tour of L (short intro)</a></li>
                   <li><a href="/documentation/intro/long">Descent into L (long intro)</a></li>
                   <li role="presentation" class="divider"></li>
                   <li class="dropdown-header">Inside the compiler</li>
                   <li><a href="/documentation/compiler_hyperbook/compilation_passes.ml">Compiler hyperbook</a></li>
                 </ul>
               </li>

               

               <li class="dropdown">
                 <a href="/blog" class="dropdown-toggle"
                    data-toggle="dropdown"> Blog <b class="caret"></b> </a>
                 <ul class="dropdown-menu">
                   <li class="dropdown-header">Recent posts</li>
                   
                   <li><a href="/blog/TDOP---Pratt-parser-in-pictures">TDOP / Pratt parser in pictures</a></li>
                   
                   <li><a href="/blog/Structuring-the-compiler">Structuring the compiler</a></li>
                   
                   <li><a href="/blog/Compiling-pattern-matching">Compiling pattern matching</a></li>
                   
                   <li><a href="/blog/A-framework-for-CPS-transformation-and-a-Github-account">A framework for CPS transformation (and a Github account)</a></li>
                   
                   <li><a href="/blog/Using-OCaml-packages-with-ocamlbuild-a-recipe">Using OCaml packages with ocamlbuild: a recipe</a></li>
                   
                   <li><a href="/blog/A-literate-union-find-data-structure">A literate union-find data structure</a></li>
                   
                   <li><a href="/blog/CPS-to-LLVM-SSA-conversion-in-literate-programming">CPS to LLVM SSA conversion in literate programming</a></li>
                   
                   <li><a href="/blog/Incorporating-C-code-in-an-Ocaml-project-using-Ocamlbuild">Incorporating C code in an Ocaml project using Ocamlbuild</a></li>
                   
                   <li><a href="/blog/A-typecast-with-many-uses">A typecast with many uses</a></li>
                   
                   <li><a href="/blog/Guaranteed-optimizations-for-system-programming-languages">Guaranteed optimizations for system programming languages</a></li>
                   
                   <li class="divider"></li>
                   <li><a href="/blog">More blog entries...</a></li>
                 </ul>
               </li>

               <li><a href="https://github.com/mlemerre/l-lang">GitHub</a></li>

             </ul>

             
           </div><!--/.nav-collapse -->
         </div>
       </div>

     <div class="container">
     <div class="row">
  <div class="col-md-3">
    <ul class="sidenav">
      <li><h4>Blog posts</h4></li>
      <hr>
      
      <li>
        <a href="/blog/TDOP---Pratt-parser-in-pictures">TDOP / Pratt parser in pictures
        </a>
        <hr>
      </li>
      
      <li>
        <a href="/blog/Structuring-the-compiler">Structuring the compiler
        </a>
        <hr>
      </li>
      
      <li>
        <a href="/blog/Compiling-pattern-matching">Compiling pattern matching
        </a>
        <hr>
      </li>
      
      <li>
        <a href="/blog/A-framework-for-CPS-transformation-and-a-Github-account">A framework for CPS transformation (and a Github account)
        </a>
        <hr>
      </li>
      
      <li>
        <a href="/blog/Using-OCaml-packages-with-ocamlbuild-a-recipe">Using OCaml packages with ocamlbuild: a recipe
        </a>
        <hr>
      </li>
      
      <li>
        <a href="/blog/A-literate-union-find-data-structure">A literate union-find data structure
        </a>
        <hr>
      </li>
      
      <li>
        <a href="/blog/CPS-to-LLVM-SSA-conversion-in-literate-programming">CPS to LLVM SSA conversion in literate programming
        </a>
        <hr>
      </li>
      
      <li>
        <a href="/blog/Incorporating-C-code-in-an-Ocaml-project-using-Ocamlbuild">Incorporating C code in an Ocaml project using Ocamlbuild
        </a>
        <hr>
      </li>
      
      <li>
        <a href="/blog/A-typecast-with-many-uses">A typecast with many uses
        </a>
        <hr>
      </li>
      
      <li>
        <a href="/blog/Guaranteed-optimizations-for-system-programming-languages">Guaranteed optimizations for system programming languages
        </a>
        <hr>
      </li>
      
      <li>
        <a href="/blog/My-first-blog-entry">My first blog entry
        </a>
        <hr>
      </li>
      
    </ul>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- Sidenav ad -->
    <ins class="adsbygoogle"
         style="display:inline-block;width:160px;height:600px"
         data-ad-client="ca-pub-1474733849095522"
         data-ad-slot="1578516477"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

  </div>
  <div class="col-md-9">
    <div class="post-title">
      <h1>A literate union-find data structure</h1>
      <i>by:</i> <b>Matthieu Lemerre</b>&nbsp;
      <i>tags:</i> <b>literateprogramming and algorithm</b>&nbsp;
      <i>published:</i> <b>07 October 2012</b>
    </div>
    <p>

</p>

<p>
I have a working closure conversion done using the purely functional
CPS data structure presented in my earlier post, but it is somewhat
hackish. Thus I am trying to improve it, following Andrew Kennedy's
excellent paper "Compiling with continuations, continued". 
</p>

<p>
Kennedy's CPS structure requires a <a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">union-find data structure</a>, used to
merge the occurences of a variable, and find the binding site of an
occurence. I already had a union-find data structure, used to
implement first-order <a href="http://en.wikipedia.org/wiki/Unification_(computer_science)">unification</a> in <a href="http://en.wikipedia.org/wiki/Type_inference">type inference</a>, but as is usual a
module becomes good on the second time you write it (when you have
more experience about its implementation and usage).
</p>

<!-- end_excerpt -->

<p>
There are many possible variations in the interface of a union-find
module. The particularities of this one is explicit support for
attaching description to sets, and a "partition" type separate from
the "element" type. Also, the interface is functorial, and I provided
two versions: a Safe one that checks that usage of the structure is
correct, and a Fast one with no check. It is easy to shoot yourself in
the foot by using this module incorrectly, so using the Safe one is
probably a better bet.
</p>

<p>
So here they are.
</p>

<!--CUT DEF section 1 --><!--TOC section Interface for module Union_find-->
<H2 CLASS="section"><!--SEC ANCHOR -->Interface for module Union_find</H2><!--SEC END --><P>
<B>1.</B> 
<A NAME="src/support/union_find.mli:0"></A><A NAME="src/support/union_find.mli:42"></A>A union-find data structure maintains a partition of elements into
disjoint sets.</P><P>It allows to add new elements in new partitions, perform the union
of two partitions, and retrieve the partition in which is an
element. Moreover it allows to attach a description to a partition,
which is generally the point of using such a structure.</P><P>This module has side effects: adding an element to a union-find
data structure changes that element, and the union operation merges
the partitions destructively. This make it easy to use this module
incorrectly. To that end, a number of protections (using types and
dynamic checks) are set that detect such incorrect uses of the
module. </P><P>Note on the name: there are other data structures that maintain
disjoint sets with other operations, such as partition refinement,
so "union-find" is a more accurate name for this data structure
than "disjoint set". 
<BR><A NAME="src/support/union_find.mli:969"></A>
<div class="ocamlweb-src"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #0000ff; font-weight: bold;">type</span> <span style="color: #228b22; ">S</span> =<BR>
<span style="color: #0000ff; font-weight: bold;">sig</span></P><P></code></div>  
The t type represents the whole union-find data structure. A
partition always belong to some t; elements belong to a t once
there has been a "singleton" operation on them. </P><P>All the functions (except <code>create</code>) take a <code>t</code> argument; in their
safe version this argument is used to checks that other
<code>element</code> and <code>partition</code> arguments indeed belong to the <code>t</code>
argument. 
<BR><A NAME="src/support/union_find.mli:1395"></A>
<div class="ocamlweb-src"><code>
  
<span style="color: #0000ff; font-weight: bold;">type</span> t<BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> partition<BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> element<BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> description</P><P></code></div>  
<code>create()</code> returns a new empty union find data structure. 
<BR><A NAME="src/support/union_find.mli:1522"></A>
<div class="ocamlweb-src"><code>
  
<span style="color: #0000ff; font-weight: bold;">val</span> create : <span style="color: #228b22; ">unit</span> &#X2192; t</P><P></code></div>  
<code>singleton t e d</code> adds a new element <code>e</code> to <code>t</code>, and create and
returns a new partition <code>p</code> in <code>t</code>, such that <code>e</code> is the only
element of <code>p</code>. It also attach the description <code>d</code> to <code>p</code>.</P><P>The safe version checks that <code>e</code> was not previously added to
another union-find data structure (with the same link). 
<BR><A NAME="src/support/union_find.mli:1879"></A>
<div class="ocamlweb-src"><code>
  
<span style="color: #0000ff; font-weight: bold;">val</span> singleton : t &#X2192; element &#X2192; description &#X2192; partition</P><P></code></div>  
<code>find t e</code> returns the partition <code>p</code> of <code>t</code> that contains <code>e</code>. 
<BR><A NAME="src/support/union_find.mli:2010"></A>
<div class="ocamlweb-src"><code>
  
<span style="color: #0000ff; font-weight: bold;">val</span> find : t &#X2192; element &#X2192; partition</P><P></code></div>  
<code>union t p1 p2 d</code> creates a new partition <code>p3</code>, with description
<code>d</code>, that contains the union of all the elements in <code>p1</code> and
<code>p2</code>. The <code>p1</code> and <code>p2</code> arguments are consumed, i.e. must not be
used after they were passed to <code>union</code>. <code>p1</code> and <code>p2</code> must be
different partitions. 
<BR><A NAME="src/support/union_find.mli:2353"></A>
<div class="ocamlweb-src"><code>
  
<span style="color: #0000ff; font-weight: bold;">val</span> union : t &#X2192; partition &#X2192; partition &#X2192; description &#X2192; partition</P><P></code></div>  
<code>description t p</code> returns the description associated to <code>p</code>. 
<BR><A NAME="src/support/union_find.mli:2493"></A>
<div class="ocamlweb-src"><code>
  
<span style="color: #0000ff; font-weight: bold;">val</span> description : t &#X2192; partition &#X2192; description</P><P></code></div>  
<code>description t p</code> changes the description associated to <code>p</code>. 
<BR><A NAME="src/support/union_find.mli:2613"></A>
<div class="ocamlweb-src"><code>
  
<span style="color: #0000ff; font-weight: bold;">val</span> set_description : t &#X2192; partition &#X2192; description &#X2192; <span style="color: #228b22; ">unit</span><BR>
<span style="color: #0000ff; font-weight: bold;">end</span><BR></code></div><B>2.</B> 
<A NAME="src/support/union_find.mli:2682"></A>We defined two types of "union-find makers": Fast and Safe. Both
propose a <code>link</code> type, and each element of a union-find structure
must be "associated" to one different link (generally the link is a
mutable field in the element type). Initially, the link value is
<code>empty_link</code>.</P><P>The <code><span style="color: #228b22; ">Make</span></code> functor, once told how access the link of an element,
returns a module complying to <code><span style="color: #228b22; ">S</span></code>. Below we given an exemple of
usage.</P><P>Note: It is possible for an element to be present in two different
union-find data structures; it must just have different links. </P><P>If the link in an element must be re-used for another union-find
data structure, then it must be set to <code>empty_link</code>, and one must
stop using the union-find data structure that contained the element
(even with other elements). 
<BR><A NAME="src/support/union_find.mli:3488"></A>
<div class="ocamlweb-src"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #0000ff; font-weight: bold;">type</span> <span style="color: #228b22; ">UNION_FIND</span> = <span style="color: #0000ff; font-weight: bold;">sig</span><BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> (&#X3B1;, &#X3B2;) link<BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> empty_link:(&#X3B1;,&#X3B2;) link</P><P><A NAME="src/support/union_find.mli:3569"></A>  
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #0000ff; font-weight: bold;">type</span> <span style="color: #228b22; ">LINK</span> =<BR>  
<span style="color: #0000ff; font-weight: bold;">sig</span><BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> element<BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> description<BR>    
<span style="color: #0000ff; font-weight: bold;">val</span> get : element &#X2192; (description, element) link<BR>    
<span style="color: #0000ff; font-weight: bold;">val</span> set : element &#X2192; (description, element) link &#X2192; <span style="color: #228b22; ">unit</span><BR>  
<span style="color: #0000ff; font-weight: bold;">end</span></P><P><A NAME="src/support/union_find.mli:3755"></A>  
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Make</span>(<span style="color: #228b22; ">Link</span> : <span style="color: #228b22; ">LINK</span>):<span style="color: #228b22; ">S</span> <span style="color: #a020f0; ">with</span> <span style="color: #0000ff; font-weight: bold;">type</span> description = <span style="color: #228b22; ">Link.</span>description <span style="color: #0000ff; font-weight: bold;">and</span> <span style="color: #0000ff; font-weight: bold;">type</span> element = <span style="color: #228b22; ">Link.</span>element<BR>
<span style="color: #0000ff; font-weight: bold;">end</span></P><P></code></div>
The difference between the fast and safe version is that safe
performs additional checks. The performance difference is small, so
the Safe version should be prefered. 
<BR><A NAME="src/support/union_find.mli:4041"></A>
<div class="ocamlweb-src"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Fast</span>:<span style="color: #228b22; ">UNION_FIND</span></P><P><A NAME="src/support/union_find.mli:4066"></A>
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Safe</span>:<span style="color: #228b22; ">UNION_FIND</span><BR></code></div><B>3.</B> 
<A NAME="src/support/union_find.mli:4094"></A>Exemple of usage:</P><P><code><span style="color: #0000ff; font-weight: bold;">type</span> test = { x:<span style="color: #228b22; ">int</span>; <span style="color: #a020f0; ">mutable</span> z:(<span style="color: #228b22; ">string</span>, test) <span style="color: #228b22; ">Union_find</span>.<span style="color: #228b22; ">Safe</span>.link };;</code></P><P><code><span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Test</span> = <span style="color: #0000ff; font-weight: bold;">struct</span>
 <span style="color: #0000ff; font-weight: bold;">type</span> description = <span style="color: #228b22; ">string</span>
 <span style="color: #0000ff; font-weight: bold;">type</span> element = test
 <span style="color: #0000ff; font-weight: bold;">let</span> get_link t = t.z
 <span style="color: #0000ff; font-weight: bold;">let</span> set_link t z = t.z &#X2190; z
 <span style="color: #0000ff; font-weight: bold;">end</span></code></P><P><code><span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">A</span> = <span style="color: #228b22; ">Union_find</span>.<span style="color: #228b22; ">Safe</span>.<span style="color: #228b22; ">Make</span>(<span style="color: #228b22; ">Test</span>)</code></P><P><code><span style="color: #0000ff; font-weight: bold;">let</span> uf = <span style="color: #228b22; ">A</span>.create() <span style="color: #0000ff; font-weight: bold;">in</span>
 <span style="color: #0000ff; font-weight: bold;">let</span> elt1 = {x=1; z=<span style="color: #228b22; ">Safe</span>.empty_link} <span style="color: #0000ff; font-weight: bold;">in</span>
 <span style="color: #0000ff; font-weight: bold;">let</span> part1 = <span style="color: #228b22; ">A</span>.singleton t elt1 <span style="color: #8b2252; ">"1"</span> <span style="color: #0000ff; font-weight: bold;">in</span>
 <span style="color: #a020f0; ">assert</span>(<span style="color: #228b22; ">A</span>.description t (<span style="color: #228b22; ">A</span>.find t elt1) = <span style="color: #8b2252; ">"1"</span>)</code> 
<BR></P><!--CUT END -->

<!--CUT DEF section 1 --><!--TOC section Module Union_find-->
<H2 CLASS="section"><!--SEC ANCHOR -->Module Union_find</H2><!--SEC END --><P>
<B>1.</B> 
<A NAME="src/support/union_find.ml:0"></A><A NAME="src/support/union_find.ml:41"></A>We represent each disjoint set by a tree : elements are in the
same set than the element that they point to.</P><P>The root of the tree is the representative of the set, and
corresponds to elements of type <code>partition</code>. It points to a
"partition descriptor". 
<BR><A NAME="src/support/union_find.ml:307"></A>
<div class="ocamlweb-src"><code>

<span style="color: #0000ff; font-weight: bold;">type</span> (&#X3B1;,&#X3B2;) baselink = <BR>  
&#X2223; <span style="color: #228b22; ">Partition_descriptor</span> <span style="color: #a52a2a; ">of</span> &#X3B1; partition_descriptor<BR>  
&#X2223; <span style="color: #228b22; ">Parent</span> <span style="color: #a52a2a; ">of</span> &#X3B2;</P><P></code></div>
The partition descriptor contains the user-accessible description,
and a rank, used to optimize the union operation.</P><P>Note that the partition descriptor is not accessible by the users
of the module, and the interface make it so that there can be only
one link to the partition descriptor (from the representative).
This allows to update the partition descriptor destructively. 
<BR><A NAME="src/support/union_find.ml:825"></A>
<div class="ocamlweb-src"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> &#X3B1; partition_descriptor = { <span style="color: #a020f0; ">mutable</span> rank:rank; <span style="color: #a020f0; ">mutable</span> desc:&#X3B1; }</P><P></code></div>
The rank of a partition is is a majorant of the distance of its
elements to the root (path compression makes so that the height of
the tree can be lower than the rank). The union operation minimizes
the rank, and thus the height of the tree. 
<BR><A NAME="src/support/union_find.ml:1152"></A>
<div class="ocamlweb-src"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> rank = <span style="color: #228b22; ">int</span><BR></code></div><B>2.</B> 
<A NAME="src/support/union_find.ml:1172"></A>The implementation is parametrized by the safety checks that we
perform (which differs between the Fast and Safe modules). </P><P>The safe module identifies all union-find data structures by a
unique id, embed that in the links, and checks for all operation
that they are equal. It also checks initialization of the link. 
<BR><A NAME="src/support/union_find.ml:1504"></A>
<div class="ocamlweb-src"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #0000ff; font-weight: bold;">type</span> <span style="color: #228b22; ">SAFETY</span> = <span style="color: #0000ff; font-weight: bold;">sig</span><BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> t<BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> create: <span style="color: #228b22; ">unit</span> &#X2192; t<BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> (&#X3B1;,&#X3B2;) link</P><P><A NAME="src/support/union_find.ml:1583"></A>  
<span style="color: #b22222">(&#X2217;  Create a safe link from a baselink.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> securize: t &#X2192; (&#X3B1;,&#X3B2;) baselink &#X2192; (&#X3B1;,&#X3B2;) link</P><P><A NAME="src/support/union_find.ml:1683"></A>  
<span style="color: #b22222">(&#X2217;  Returns the base_link from the safe link.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> get_base: (&#X3B1;,&#X3B2;) link &#X2192; (&#X3B1;,&#X3B2;) baselink</P><P><A NAME="src/support/union_find.ml:1784"></A>  
<span style="color: #b22222">(&#X2217;  Check the safe link withat the element (and the safe link) belong to t.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> check_membership: t &#X2192; (&#X3B1;,&#X3B2;) link &#X2192; <span style="color: #228b22; ">unit</span></P><P><A NAME="src/support/union_find.ml:1916"></A>  
<span style="color: #b22222">(&#X2217;  Check that the element is not yet part of any union find.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> check_unused: (&#X3B1;,&#X3B2;) link &#X2192; <span style="color: #228b22; ">unit</span></P><P><A NAME="src/support/union_find.ml:2025"></A>  
<span style="color: #b22222">(&#X2217;  Initial link.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> empty_link: (&#X3B1;,&#X3B2;) link<BR>
<span style="color: #0000ff; font-weight: bold;">end</span></P><P><A NAME="src/support/union_find.ml:2086"></A>
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">No_safety</span>:<span style="color: #228b22; ">SAFETY</span> = <span style="color: #0000ff; font-weight: bold;">struct</span><BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> t = <span style="color: #228b22; ">unit</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> create() = ()<BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> (&#X3B1;,&#X3B2;) link = (&#X3B1;,&#X3B2;) baselink</P><P><A NAME="src/support/union_find.ml:2196"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> securize () l = l</P><P><A NAME="src/support/union_find.ml:2222"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> check_membership () l = ()</P><P><A NAME="src/support/union_find.ml:2257"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> check_unused l = ()</P><P><A NAME="src/support/union_find.ml:2285"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> get_base l = l</P><P><A NAME="src/support/union_find.ml:2308"></A>  
<span style="color: #b22222">(&#X2217;  Note: This cast can make the execution fail without notice.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> empty_link = <span style="color: #228b22; ">Obj.</span>magic 0 <BR>
<span style="color: #0000ff; font-weight: bold;">end</span></P><P><A NAME="src/support/union_find.ml:2423"></A>
<span style="color: #0000ff; font-weight: bold;">type</span> unique = <span style="color: #228b22; ">int</span></P><P><A NAME="src/support/union_find.ml:2442"></A>
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Unique</span> = <span style="color: #228b22; ">Unique.Make</span>(<span style="color: #0000ff; font-weight: bold;">struct</span> <span style="color: #0000ff; font-weight: bold;">end</span>)</P><P><A NAME="src/support/union_find.ml:2483"></A>
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Safety</span>:<span style="color: #228b22; ">SAFETY</span> = <span style="color: #0000ff; font-weight: bold;">struct</span><BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> t = <span style="color: #228b22; ">Unique.</span>t<BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> create() = <span style="color: #228b22; ">Unique.</span>fresh()</P><P><A NAME="src/support/union_find.ml:2567"></A>  
<span style="color: #0000ff; font-weight: bold;">type</span> (&#X3B1;,&#X3B2;) link = t <span style="color: #228b22; ">option</span> × (&#X3B1;,&#X3B2;) baselink</P><P><A NAME="src/support/union_find.ml:2619"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> securize u l = (<span style="color: #228b22; ">Some</span> u,l)</P><P><A NAME="src/support/union_find.ml:2653"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> check_membership t (u,_) = <BR>    
(<span style="color: #a020f0; ">match</span> u <span style="color: #a020f0; ">with</span><BR>      
&#X2223; <span style="color: #228b22; ">Some</span>(a) &#X2192; <span style="color: #a020f0; ">assert</span> (t &#X2261; a) <span style="color: #b22222">(&#X2217;  The element is in another union-find structure.  &#X2217;)</span><BR>      
&#X2223; <span style="color: #228b22; ">None</span> &#X2192; <span style="color: #a020f0; ">assert</span> <span style="color: #a020f0; ">false</span>); () <span style="color: #b22222">(&#X2217;  The element is in no union-find structure.  &#X2217;)</span></P><P><A NAME="src/support/union_find.ml:2882"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> check_unused (u,_) = <BR>    
(<span style="color: #a020f0; ">match</span> u <span style="color: #a020f0; ">with</span><BR>      
&#X2223; <span style="color: #228b22; ">Some</span>(_) &#X2192; <span style="color: #a020f0; ">assert</span> <span style="color: #a020f0; ">false</span> <span style="color: #b22222">(&#X2217;  The element is already in a union-find structure.  &#X2217;)</span><BR>      
&#X2223; <span style="color: #228b22; ">None</span> &#X2192; ())</P><P><A NAME="src/support/union_find.ml:3041"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> get_base (_,l) = l</P><P><A NAME="src/support/union_find.ml:3068"></A>  
<span style="color: #b22222">(&#X2217;  Note: The cast is not dangerous, because the left-hand part is
checked first.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> empty_link = (<span style="color: #228b22; ">None</span>, <span style="color: #228b22; ">Obj.</span>magic 0) <BR>
<span style="color: #0000ff; font-weight: bold;">end</span><BR></code></div><B>3.</B> 
<A NAME="src/support/union_find.ml:3207"></A>The goal of the below "double functor" is to produce a module with
the following signature. In it, <code>partition</code> and <code>element</code> are
actually the same underlying type; the difference is that elements
returned with type <code>partition</code> are the root of the tree). Hiding
this in the interface provides some guarantee that arguments of type
partition are the representative of their partition.</P><P>Unfortunately, after calling <code>union</code> on two partitions <code>p1</code> and
<code>p2</code>, one of them will stop being the root; that is why the
partition arguments of <code>union</code> must not be re-used. Thus, defining
the <code>partition</code> type only guarantees that the argument has been a
root in the past, and we ensure that by a dynamic test. 
<BR><A NAME="src/support/union_find.ml:3929"></A>
<div class="ocamlweb-src"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #0000ff; font-weight: bold;">type</span> <span style="color: #228b22; ">S</span> = <span style="color: #0000ff; font-weight: bold;">sig</span><BR>      
<span style="color: #0000ff; font-weight: bold;">type</span> t<BR>      
<span style="color: #0000ff; font-weight: bold;">type</span> partition<BR>      
<span style="color: #0000ff; font-weight: bold;">type</span> element<BR>      
<span style="color: #0000ff; font-weight: bold;">type</span> description<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> create: <span style="color: #228b22; ">unit</span> &#X2192; t<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> singleton : t &#X2192; element &#X2192; description &#X2192; partition<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> find : t &#X2192; element &#X2192; partition<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> union: t &#X2192; partition &#X2192; partition &#X2192; description &#X2192; partition<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> description: t &#X2192; partition &#X2192; description<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> set_description : t &#X2192; partition &#X2192; description &#X2192; <span style="color: #228b22; ">unit</span><BR>
<span style="color: #0000ff; font-weight: bold;">end</span></P><P></code></div>
This is a double functor with two arguments; <code><span style="color: #228b22; ">Saf</span></code> allows to
differenciate the "Fast" and "Safe" modules, while <code><span style="color: #228b22; ">Link</span></code> is used
to find and change the link. 
<BR><A NAME="src/support/union_find.ml:4980"></A>
<div class="ocamlweb-src"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Make</span>(<span style="color: #228b22; ">Saf</span>:<span style="color: #228b22; ">SAFETY</span>):<span style="color: #228b22; ">UNION_FIND</span> = <BR>
<span style="color: #0000ff; font-weight: bold;">struct</span></P><P><A NAME="src/support/union_find.ml:5026"></A>  
<span style="color: #0000ff; font-weight: bold;">type</span> (&#X3B1;,&#X3B2;) link = (&#X3B1;,&#X3B2;) <span style="color: #228b22; ">Saf.</span>link</P><P><A NAME="src/support/union_find.ml:5067"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> empty_link = <span style="color: #228b22; ">Saf.</span>empty_link</P><P><A NAME="src/support/union_find.ml:5104"></A>  
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #0000ff; font-weight: bold;">type</span> <span style="color: #228b22; ">LINK</span> = <span style="color: #0000ff; font-weight: bold;">sig</span><BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> element<BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> description<BR>    
<span style="color: #0000ff; font-weight: bold;">val</span> get: element &#X2192; (description, element) link <BR>    
<span style="color: #0000ff; font-weight: bold;">val</span> set: element &#X2192; (description, element) link &#X2192; <span style="color: #228b22; ">unit</span><BR>  
<span style="color: #0000ff; font-weight: bold;">end</span></P><P><A NAME="src/support/union_find.ml:5290"></A>  
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Make</span>(<span style="color: #228b22; ">Link</span>: <span style="color: #228b22; ">LINK</span>) =<BR>  
<span style="color: #0000ff; font-weight: bold;">struct</span><BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> t = <span style="color: #228b22; ">Saf.</span>t<BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> element = <span style="color: #228b22; ">Link.</span>element<BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> description = <span style="color: #228b22; ">Link.</span>description<BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> partition = <span style="color: #228b22; ">Link.</span>element</P><P><A NAME="src/support/union_find.ml:5453"></A>    
<span style="color: #0000ff; font-weight: bold;">let</span> create = <span style="color: #228b22; ">Saf.</span>create<BR></code></div><B>4.</B> 
<A NAME="src/support/union_find.ml:5490"></A><code>singleton</code> is the only way to add new elements to the
union-find structure, and is the place where we check that the
element is not part of another structure. 
<BR><A NAME="src/support/union_find.ml:5667"></A>
<div class="ocamlweb-src"><code>
    
<span style="color: #0000ff; font-weight: bold;">let</span> singleton t elt desc = <BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> l = (<span style="color: #228b22; ">Link.</span>get elt) <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #228b22; ">Saf.</span>check_unused l;<BR>      
<span style="color: #228b22; ">Link.</span>set elt (<span style="color: #228b22; ">Saf.</span>securize t (<span style="color: #228b22; ">Partition_descriptor</span> {rank=0;desc=desc}));<BR>      
elt <BR></code></div><B>5.</B> 
<A NAME="src/support/union_find.ml:5856"></A>Basically, <code>find</code> just walks the tree until it finds the root.</P><P>But performance is increased if the length of the path is
diminished: traversed nodes are linked to nodes that are closer
to the roof. The possibility we have implemented is path
compression: when the root is found, the elements are changed
to link to the it, so that subsequent calls are faster. We
implemented a tail-recursive version of this algorithm (which
still requires two pass).</P><P>Note: there are alternatives to path compression, such that
halving; but in Tarjan&#X2019;s structure the root is linked to
itself, which is not the case here, so halving would require
more checks than in Tarjan&#X2019;s version. Thus we stick with path
compression. </P><P>Note: we could perform a lighter check in the safe version by
checking only the argument, and not all recursive calls; this is
probably not worth implementing it, and the heavy check has its
uses. 
<BR><A NAME="src/support/union_find.ml:6868"></A>
<div class="ocamlweb-src"><code>
    
<span style="color: #0000ff; font-weight: bold;">let</span> find t x = <BR>      
<span style="color: #b22222">(&#X2217;  Tail-recursive function to find the root of the algorithm.  &#X2217;)</span><BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> <span style="color: #0000ff; font-weight: bold;">rec</span> find x = <BR>        
<span style="color: #0000ff; font-weight: bold;">let</span> l = (<span style="color: #228b22; ">Link.</span>get x) <span style="color: #0000ff; font-weight: bold;">in</span><BR>        
<span style="color: #228b22; ">Saf.</span>check_membership t l;<BR>        
<span style="color: #a020f0; ">match</span> <span style="color: #228b22; ">Saf.</span>get_base l <span style="color: #a020f0; ">with</span><BR>          
&#X2223; <span style="color: #228b22; ">Partition_descriptor</span>(s) &#X2192; x<BR>          
&#X2223; <span style="color: #228b22; ">Parent</span>(y) &#X2192; find y <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #b22222">(&#X2217;  This is also tail-recursive, but we do not perform the checks
the second time. &#X2217;)</span><BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> <span style="color: #0000ff; font-weight: bold;">rec</span> compress x r = <BR>        
<span style="color: #0000ff; font-weight: bold;">let</span> l = (<span style="color: #228b22; ">Link.</span>get x) <span style="color: #0000ff; font-weight: bold;">in</span><BR>        
<span style="color: #a020f0; ">match</span> <span style="color: #228b22; ">Saf.</span>get_base l <span style="color: #a020f0; ">with</span><BR>          
&#X2223; <span style="color: #228b22; ">Partition_descriptor</span>(s) &#X2192; ()<BR>          
&#X2223; <span style="color: #228b22; ">Parent</span>(y) &#X2192; <span style="color: #228b22; ">Link.</span>set x (<span style="color: #228b22; ">Saf.</span>securize t (<span style="color: #228b22; ">Parent</span> r)) <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> root = find x <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
compress x root;<BR>      
root<BR></code></div><B>6.</B> 
<A NAME="src/support/union_find.ml:7541"></A>The following functions work only when the given element is
the root of a partition, but check that. 
<BR><A NAME="src/support/union_find.ml:7653"></A>
<div class="ocamlweb-src"><code>
    
<span style="color: #0000ff; font-weight: bold;">let</span> get_partition_descriptor t p = <BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> l = (<span style="color: #228b22; ">Link.</span>get p) <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #228b22; ">Saf.</span>check_membership t l;<BR>      
<span style="color: #a020f0; ">match</span> <span style="color: #228b22; ">Saf.</span>get_base l <span style="color: #a020f0; ">with</span><BR>        
&#X2223; <span style="color: #228b22; ">Partition_descriptor</span>(s) &#X2192; s<BR>        
&#X2223; _ &#X2192; <span style="color: #a020f0; ">assert</span>(<span style="color: #a020f0; ">false</span>) <span style="color: #b22222">(&#X2217;  The element is not a partition.  &#X2217;)</span></P><P><A NAME="src/support/union_find.ml:7897"></A>    
<span style="color: #0000ff; font-weight: bold;">let</span> description t x = (get_partition_descriptor t x).desc</P><P><A NAME="src/support/union_find.ml:7962"></A>    
<span style="color: #0000ff; font-weight: bold;">let</span> set_description t x desc = <BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> pd = get_partition_descriptor t x <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
pd.desc &#X2190; desc<BR></code></div><B>7.</B> 
<A NAME="src/support/union_find.ml:8080"></A>This function performs the union of two partitions. We use
rank to find which should be the root : we attach the smaller
tree to the root of the larger tree, so as not to increase the
maximum height (i.e. path length) of the resulting tree.</P><P>The last argument allows to update the set descriptor along
with this operation.</P><P>Note that this function takes partitions as argument; one could
have instead taken any element, and performed the find inside
the function; in particular some efficient algorithms
interleave the find and union operations. The reason why we
take partition arguments is that it avoids a find when we know
that the argument is a partition (for instance when merging
with a just-created singleton), and the user needs to perform a
find to retrieve and merge the description in the algorithms we
use (such as unification). 
<BR><A NAME="src/support/union_find.ml:9011"></A>
<div class="ocamlweb-src"><code>
    
<span style="color: #0000ff; font-weight: bold;">let</span> union t p1 p2 newdesc =</P><P></code></div>      
This function also checks that p1 and p2 are partitions. 
<BR><A NAME="src/support/union_find.ml:9114"></A>
<div class="ocamlweb-src"><code>
      
<span style="color: #0000ff; font-weight: bold;">let</span> d1 = get_partition_descriptor t p1 <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> d2 = get_partition_descriptor t p2 <span style="color: #0000ff; font-weight: bold;">in</span></P><P></code></div>      
Alternatively, the check that p1 and p2 are different could
have been done here. 
<BR><A NAME="src/support/union_find.ml:9313"></A>
<div class="ocamlweb-src"><code>
      
<span style="color: #a020f0; ">assert</span> (p1 &#X2260; p2);<BR>      
<span style="color: #a020f0; ">if</span>( d1.rank &lt; d2.rank) <span style="color: #a020f0; ">then</span> <BR>        
<span style="color: #0000ff; font-weight: bold;">begin</span> <BR>          
<span style="color: #b22222">(&#X2217;  Keep d2_repr as root. Height of the merge is max(d1_height +1, d2_height) so does not change.  &#X2217;)</span><BR>          
<span style="color: #228b22; ">Link.</span>set p1 (<span style="color: #228b22; ">Saf.</span>securize t (<span style="color: #228b22; ">Parent</span> p2));<BR>          
d2.desc &#X2190; newdesc;<BR>          
p2<BR>        
<span style="color: #0000ff; font-weight: bold;">end</span><BR>      
<span style="color: #a020f0; ">else</span> <span style="color: #a020f0; ">if</span> (d1.rank &gt; d2.rank) <span style="color: #a020f0; ">then</span><BR>        
<span style="color: #0000ff; font-weight: bold;">begin</span> <BR>          
<span style="color: #b22222">(&#X2217;  Keep d1_repr as root. Height of the merge is max(d2_height +1, d1_height) so does not change.  &#X2217;)</span><BR>          
<span style="color: #228b22; ">Link.</span>set p2 (<span style="color: #228b22; ">Saf.</span>securize t (<span style="color: #228b22; ">Parent</span> p1));<BR>          
d1.desc &#X2190; newdesc;<BR>          
p1<BR>        
<span style="color: #0000ff; font-weight: bold;">end</span><BR>      
<span style="color: #a020f0; ">else</span> <BR>        
<span style="color: #0000ff; font-weight: bold;">begin</span><BR>          
<span style="color: #b22222">(&#X2217;  We choose arbitrarily p1 to be the root. 
         The height may have changed, as all elements in the subset
         with root p2 are 1 step further to the root.  &#X2217;)</span><BR>          
<span style="color: #228b22; ">Link.</span>set p2 (<span style="color: #228b22; ">Saf.</span>securize t (<span style="color: #228b22; ">Parent</span> p1));<BR>          
d1.rank &#X2190; d1.rank + 1; d1.desc &#X2190; newdesc;<BR>          
p1<BR>        
<span style="color: #0000ff; font-weight: bold;">end</span><BR>  
<span style="color: #0000ff; font-weight: bold;">end</span></P><P><A NAME="src/support/union_find.ml:10180"></A>
<span style="color: #0000ff; font-weight: bold;">end</span><BR></code></div><B>8.</B> 
<A NAME="src/support/union_find.ml:10189"></A>The double-functor is not shown in the exposed interface, and we
only export the following, simpler modules. 
<BR><A NAME="src/support/union_find.ml:10305"></A>
<div class="ocamlweb-src"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Fast</span>=<span style="color: #228b22; ">Make</span>(<span style="color: #228b22; ">No_safety</span>)</P><P><A NAME="src/support/union_find.ml:10335"></A>
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Safe</span>=<span style="color: #228b22; ">Make</span>(<span style="color: #228b22; ">Safety</span>)<BR></code></div><B>9.</B> 
<A NAME="src/support/union_find.ml:10365"></A>For a survey of the implementations of union-find algorithms, one
should read "Worst-Case Analysis of Set Union Algorithms", by
Tarjan and Van Leeuwen.</P><P>Recent performance comparison of these algorithms (and modern
enhancements) can be found in "Experiments on Union-Find Algorithms
for the Disjoint-Set Data Structure", by Md. Mostofa Ali Patwary,
Jean Blair, Fredrik Manne. 
<BR></P><!--CUT END -->

    <hr />
    <div class="footer">



      

      <ul class="social-share">
        <li class="social-share-item"><b>Follow:</b></li>
        <li class="social-share-item">
          <a class="social-share-link social-ico-rss"
             href="/blog/rss.xml" target="_blank">RSS</a>
        </li>
        <li class="social-share-item">
          <a class="social-share-link social-ico-rss"
             href="/blog/atom.xml" target="_blank">Atom</a>
        </li>

        
        <li class="social-share-item">
          <a class="social-share-link social-ico-twitter"
             href="https://twitter.com/intent/follow?original_referer=http://l-lang.org/blog/A-literate-union-find-data-structure&screen_name=l_language"
             rel="nofollow" target="_blank">@l_language</a>
        </li>
      </ul>

      <ul class="social-share">
        <li class="social-share-item"><b>Contact:</b></li>
        <li class="social-share-item">
          <a class="social-share-link social-ico-e_mail"
             rel="nofollow"
             target="_blank"><span class="my-email">matt*l-lang.org</span></a>
        </li>

        <li class="social-share-item"><b>&nbsp;&nbsp;Support:</b></li>

        <li class="social-share-item">
          <a class="social-share-link social-ico-flattr"
             href="https://flattr.com/submit/auto?user_id=mlemerre&title=A+literate+union-find+data+structure&url=http%3A%2F%2Fl-lang.org%2Fblog%2FA-literate-union-find-data-structure&tags=programming,l&category=software"
             rel="nofollow" target="_blank">Flattr</a>
        </li>

        

        <li class="social-share-item">
          <form action="https://www.paypal.com/cgi-bin/webscr"
                method="post" target="_top"
                 >
            <input type="hidden" name="cmd" value="_s-xclick">
            <input type="hidden" name="hosted_button_id"
             value="2TFN99SEWMEHE">
            <input type="image"
                   src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif"
                   border="0" name="submit" alt="PayPal - The safer,
                                                 easier way to pay
                                                 online!"
                   style="vertical-align:middle"> 
            <!-- <img alt="" border="0" src="https://www.paypalobjects.com/fr_FR/i/scr/pixel.gif" width="1" height="2">  -->

          </form>
        </li>

        

      </ul>

      <ul class="social-share">
        <li class="social-share-item"><b>Share:</b></li>

        <li class="social-share-item">
          <a class="social-share-link social-ico-google"
             href="http://plus.google.com/share?url=http%3A%2F%2Fl-lang.org%2Fblog%2FA-literate-union-find-data-structure"
             rel="nofollow" target="_blank">Google+</a>
        </li>
        <li class="social-share-item">
          <a class="social-share-link social-ico-twitter"
             href="http://twitter.com/share?text=New+blog+post+on+L%3A+%22A+literate+union-find+data+structure%22&url=http%3A%2F%2Fl-lang.org%2Fblog%2FA-literate-union-find-data-structure&counturl=http%3A%2F%2Fl-lang.org%2Fblog%2FA-literate-union-find-data-structure&via=l_language&related=l_language"
             rel="nofollow" target="_blank">Twitter</a>
        </li>

        <li class="social-share-item">
          <a class="social-share-link social-ico-hackernews"
             href="http://news.ycombinator.com/submitlink?u=http%3A%2F%2Fl-lang.org%2Fblog%2FA-literate-union-find-data-structure"
             rel="nofollow" target="_blank">Hacker News</a>
        </li>

        <li class="social-share-item">
          <a class="social-share-link social-ico-reddit"
             href="http://www.reddit.com/submit?title=A literate union-find data structure&url=http%3A%2F%2Fl-lang.org%2Fblog%2FA-literate-union-find-data-structure"
             rel="nofollow" target="_blank">Reddit</a>
        </li>

        <li class="social-share-item">
          <a class="social-share-link social-ico-facebook"
             href="http://www.facebook.com/sharer.php?u=http%3A%2F%2Fl-lang.org%2Fblog%2FA-literate-union-find-data-structure&t=A literate union-find data structure"
             rel="nofollow" target="_blank">Facebook</a>
        </li>

        <li class="social-share-item">
          <a class="social-share-link social-ico-e_mail"
             href="mailto:?subject=A literate union-find data structure&body=http%3A%2F%2Fl-lang.org%2Fblog%2FA-literate-union-find-data-structure"
             rel="nofollow" target="_blank">Mail</a>
        </li>


        
      </ul>
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <!-- Article bottom -->
      <ins class="adsbygoogle"
           style="display:inline-block;width:728px;height:90px"
           data-ad-client="ca-pub-1474733849095522"
           data-ad-slot="4531982879"></ins>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
  </div>
</div>


 
     </div>
          

   
   <script src="/js/jquery.js"></script>
   

   <script src="/dist/js/bootstrap.min.js"></script>

   

   
   <script type="text/javascript">
   $('.my-email').html(function(){
	var d = "t@l-la";
	var e = "ma";
	var a = "t";
	var c = "ng.org";
	var h = 'mailto:' + e + a + d + c;
	$(this).parent('a').attr('href', h);
	return e + a + d + c;
   });
   </script>

  </body>
</html>
